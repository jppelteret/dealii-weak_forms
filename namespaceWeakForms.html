<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Weak forms for deal.II: WeakForms Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Weak forms for deal.II
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">WeakForms Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceWeakForms_1_1Decorations"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1Decorations.html">Decorations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1NonLinear"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1NonLinear.html">NonLinear</a></td></tr>
<tr class="memdesc:namespaceWeakForms_1_1NonLinear"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace that encapsulates aliases that are relevant for non-linear problems. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1numbers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1numbers.html">numbers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1Operators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1Operators.html">Operators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1SelfLinearization"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1SelfLinearization.html">SelfLinearization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1SubSpaceExtractors"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1SubSpaceExtractors.html">SubSpaceExtractors</a></td></tr>
<tr class="memdesc:namespaceWeakForms_1_1SubSpaceExtractors"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace dedicated to objects that help to identify subspaces within a global finite element space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1SubSpaceViews"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1SubSpaceViews.html">SubSpaceViews</a></td></tr>
<tr class="memdesc:namespaceWeakForms_1_1SubSpaceViews"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace dedicated to objects that represent a subspace within a global finite element space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1types"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1types.html">types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1Utilities"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1Utilities.html">Utilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1AD__SD__Functor__Cache.html">AD_SD_Functor_Cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent data for AD and SD calculations.  <a href="classWeakForms_1_1AD__SD__Functor__Cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1are__scalar__types.html">are_scalar_types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see two classes are both scalar types.  <a href="structWeakForms_1_1are__scalar__types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1AssemblerBase.html">AssemblerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1BilinearForm.html">BilinearForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents any linear form.  <a href="classWeakForms_1_1BilinearForm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1BoundaryIntegral.html">BoundaryIntegral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that encapsulates the subset of elements that are to be considered as part of a boundary integral.  <a href="classWeakForms_1_1BoundaryIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1FieldSolution.html">FieldSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents a (discrete) global finite element field solution.  <a href="classWeakForms_1_1FieldSolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1FunctionIntegrator.html">FunctionIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integrator for user-defined functions.  <a href="classWeakForms_1_1FunctionIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1Functor.html">Functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for other objects that represent functors.  <a href="classWeakForms_1_1Functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1Integral.html">Integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for other objects that represent (sub)domains of integration.  <a href="classWeakForms_1_1Integral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1Integrator.html">Integrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integrator for functors.  <a href="classWeakForms_1_1Integrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1InterfaceIntegral.html">InterfaceIntegral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that encapsulates the subset of elements that are to be considered as part of an interface integral.  <a href="classWeakForms_1_1InterfaceIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__ad__functor__op.html">is_ad_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that is automatically differentiable.  <a href="structWeakForms_1_1is__ad__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__bilinear__form.html">is_bilinear_form</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a binary form.  <a href="structWeakForms_1_1is__bilinear__form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__binary__integral__op.html">is_binary_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a binary operator that has been integrated.  <a href="structWeakForms_1_1is__binary__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__binary__op.html">is_binary_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a binary operator.  <a href="structWeakForms_1_1is__binary__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__boundary__integral__op.html">is_boundary_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a boundary integral (domain).  <a href="structWeakForms_1_1is__boundary__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__boundary__op.html">is_boundary_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that can be evaluated on a boundary.  <a href="structWeakForms_1_1is__boundary__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__cache__functor__op.html">is_cache_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an elementary operation involving a cached functor.  <a href="structWeakForms_1_1is__cache__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__cell__geometry__op.html">is_cell_geometry_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that involves a geometry operation of a discrete finite element (cell).  <a href="structWeakForms_1_1is__cell__geometry__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__compatible__with__scalar__arithmetic.html">is_compatible_with_scalar_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that can be sensibly used in conjunction with a scalar arithmetic operation.  <a href="structWeakForms_1_1is__compatible__with__scalar__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__energy__functor__op.html">is_energy_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator represents an energy functor.  <a href="structWeakForms_1_1is__energy__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__evaluated__with__scratch__data.html">is_evaluated_with_scratch_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that must be evaluated using deal.II's MeshWorker::ScratchData class.  <a href="structWeakForms_1_1is__evaluated__with__scratch__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__field__solution.html">is_field_solution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an operation involving the field solution (or a component thereof).  <a href="structWeakForms_1_1is__field__solution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__field__solution__op.html">is_field_solution_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is an elementary or composite (unary or binary) symbolic operator that involves the field solution (or a view into it).  <a href="structWeakForms_1_1is__field__solution__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__functor__op.html">is_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an elementary operation involving a functor.  <a href="structWeakForms_1_1is__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__integral__op.html">is_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents any operator that has been integrated.  <a href="structWeakForms_1_1is__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__interface__integral__op.html">is_interface_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an interface integral (domain).  <a href="structWeakForms_1_1is__interface__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__interface__op.html">is_interface_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that can be evaluated on an interface.  <a href="structWeakForms_1_1is__interface__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__linear__form.html">is_linear_form</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a linear form.  <a href="structWeakForms_1_1is__linear__form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__residual__functor__op.html">is_residual_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator represents a residual functor.  <a href="structWeakForms_1_1is__residual__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1is__scalar__type.html">is_scalar_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a scalar type.  <a href="classWeakForms_1_1is__scalar__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__sd__functor__op.html">is_sd_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that is symbolically differentiable.  <a href="structWeakForms_1_1is__sd__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__self__linearizing__form.html">is_self_linearizing_form</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a form that has the ability to linearise itself.  <a href="structWeakForms_1_1is__self__linearizing__form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__subspace__view.html">is_subspace_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that acts as a view into the global test function, trial solution, or field solution.  <a href="structWeakForms_1_1is__subspace__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__symbolic__integral__op.html">is_symbolic_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents another elementary operator that has been integrated.  <a href="structWeakForms_1_1is__symbolic__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__test__function.html">is_test_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an operation involving the test function (or a component thereof).  <a href="structWeakForms_1_1is__test__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__test__function__op.html">is_test_function_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is an elementary or composite (unary or binary) symbolic operator that involves the test function (or a view into it).  <a href="structWeakForms_1_1is__test__function__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__trial__solution.html">is_trial_solution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an operation involving the trial solution (or a component thereof).  <a href="structWeakForms_1_1is__trial__solution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__trial__solution__op.html">is_trial_solution_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is an elementary or composite (unary or binary) symbolic operator that involves the trial solution (or a view into it).  <a href="structWeakForms_1_1is__trial__solution__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__unary__integral__op.html">is_unary_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a unary operator that has been integrated.  <a href="structWeakForms_1_1is__unary__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__unary__op.html">is_unary_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a unary operator.  <a href="structWeakForms_1_1is__unary__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__valid__form__functor.html">is_valid_form_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a valid elementary of composite (unary or binary) symbolic operator that can be passed into, and evaluated within, a linear or binary form.  <a href="structWeakForms_1_1is__valid__form__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__valid__integration__domain.html">is_valid_integration_domain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a domain of integration.  <a href="structWeakForms_1_1is__valid__integration__domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__volume__integral__op.html">is_volume_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a volume integral (domain).  <a href="structWeakForms_1_1is__volume__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1LinearForm.html">LinearForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents any linear form.  <a href="classWeakForms_1_1LinearForm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1MatrixBasedAssembler.html">MatrixBasedAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1Normal.html">Normal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that represents the normal of the cell, as evaluated at a boundary or an interface.  <a href="classWeakForms_1_1Normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1ResidualFunctor.html">ResidualFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1ScalarCacheFunctor.html">ScalarCacheFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns (field-dependent) scalar values upon evaluation.  <a href="classWeakForms_1_1ScalarCacheFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1ScalarFunctionFunctor.html">ScalarFunctionFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that acts as a wrapper for a scalar deal.II function.  <a href="classWeakForms_1_1ScalarFunctionFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1ScalarFunctor.html">ScalarFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns scalar values upon evaluation.  <a href="classWeakForms_1_1ScalarFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1SolutionExtractionData.html">SolutionExtractionData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that facilitates the extraction of data from the field solution.  <a href="structWeakForms_1_1SolutionExtractionData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1SolutionStorage.html">SolutionStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An class that allows one to store solution vectors that may be referenced by the weak forms during assembly.  <a href="classWeakForms_1_1SolutionStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1Space.html">Space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for objects that encapsulate the notion of a (discrete) global finite element space.  <a href="classWeakForms_1_1Space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1SymbolicDecorations.html">SymbolicDecorations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1SymbolicNames.html">SymbolicNames</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1SymbolicNamesAscii.html">SymbolicNamesAscii</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1SymbolicNamesLaTeX.html">SymbolicNamesLaTeX</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1SymmetricTensorCacheFunctor.html">SymmetricTensorCacheFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns (field-dependent) symmetric tensor values upon evaluation.  <a href="classWeakForms_1_1SymmetricTensorCacheFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1SymmetricTensorFunctor.html">SymmetricTensorFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns a symmetric tensor upon evaluation.  <a href="classWeakForms_1_1SymmetricTensorFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1TensorCacheFunctor.html">TensorCacheFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns (field-dependent) tensor values upon evaluation.  <a href="classWeakForms_1_1TensorCacheFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1TensorFunctionFunctor.html">TensorFunctionFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that acts as a wrapper for a tensor-valued deal.II function.  <a href="classWeakForms_1_1TensorFunctionFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1TensorFunctor.html">TensorFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns a tensor upon evaluation.  <a href="classWeakForms_1_1TensorFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1TestFunction.html">TestFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents a (discrete) global finite element test function.  <a href="classWeakForms_1_1TestFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1TrialSolution.html">TrialSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents a (discrete) global finite element trial solution.  <a href="classWeakForms_1_1TrialSolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1VolumeIntegral.html">VolumeIntegral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that encapsulates the subset of elements that are to be considered as part of a volume integral.  <a href="classWeakForms_1_1VolumeIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0a9c531383d9c68277a50599e3e9f565"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a0a9c531383d9c68277a50599e3e9f565"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a0a9c531383d9c68277a50599e3e9f565">VectorCacheFunctor</a> = <a class="el" href="classWeakForms_1_1TensorCacheFunctor.html">TensorCacheFunctor</a>&lt; 1, dim &gt;</td></tr>
<tr class="separator:a0a9c531383d9c68277a50599e3e9f565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e444116cbcbd5ccf773acddc015de6"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a69e444116cbcbd5ccf773acddc015de6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a69e444116cbcbd5ccf773acddc015de6">VectorFunctor</a> = <a class="el" href="classWeakForms_1_1TensorFunctor.html">TensorFunctor</a>&lt; 1, dim &gt;</td></tr>
<tr class="separator:a69e444116cbcbd5ccf773acddc015de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a4e449c6edab12a90df92459fae2d6"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a76a4e449c6edab12a90df92459fae2d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a76a4e449c6edab12a90df92459fae2d6">VectorFunctionFunctor</a> = <a class="el" href="classWeakForms_1_1TensorFunctionFunctor.html">TensorFunctionFunctor</a>&lt; 1, dim &gt;</td></tr>
<tr class="separator:a76a4e449c6edab12a90df92459fae2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acaa0a4172ad5893b342da4aae68fb3a4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> { <br />
&#160;&#160;<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a34c4dedca0d31e298e5fb97dd7f47a96">form_components_default</a> = 0, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a54ecd6b612d5386ff36b545c081c2c1d">multiplicity_I</a> = 0x0001, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a52eda1df3a1fe00eb1fbc8d4693c8f7d">multiplicity_J</a> = 0x0002, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a8a40a6051a8a98cff6d5395cef34e94e">dof_I_component_i</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4acc3c6969be48c9763f101891745480e6">dof_I_component_j</a> = 0x0008, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a8d56c5d28292ad64b0978eda61d01e73">dof_J_component_i</a> = 0x0010, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4ab22689254b0cc55000ab2509c90efcce">dof_J_component_j</a> = 0x0020, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a286506621645e37af87ab00331615d9b">local_shape_function_kronecker_delta</a> = 0x0040
<br />
 }</td></tr>
<tr class="separator:acaa0a4172ad5893b342da4aae68fb3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a36e97adeeaa7ab0ed216e0587a70080c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a36e97adeeaa7ab0ed216e0587a70080c">operator|</a> (const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f1, const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f2)</td></tr>
<tr class="separator:a36e97adeeaa7ab0ed216e0587a70080c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320830063be57b317a00c519cb979e04"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a320830063be57b317a00c519cb979e04">operator|=</a> (<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;f1, const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f2)</td></tr>
<tr class="separator:a320830063be57b317a00c519cb979e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d14de582aceac693625e252b461da59"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a7d14de582aceac693625e252b461da59">operator&amp;</a> (const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f1, const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f2)</td></tr>
<tr class="separator:a7d14de582aceac693625e252b461da59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1086e3a3e67706edcefd70e630050b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a0d1086e3a3e67706edcefd70e630050b">operator&amp;=</a> (<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;f1, const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f2)</td></tr>
<tr class="separator:a0d1086e3a3e67706edcefd70e630050b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd7b5677e0e315c3c177d2dbe7cb7f7"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename Functor , typename TrialSpaceOp , typename  = typename std::enable_if&lt;is_valid_form_functor&lt;Functor&gt;::value &amp;&amp;                                       !is_scalar_type&lt;Functor&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afdd7b5677e0e315c3c177d2dbe7cb7f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1BilinearForm.html">BilinearForm</a>&lt; TestSpaceOp, <a class="el" href="classWeakForms_1_1Functor.html">Functor</a>, TrialSpaceOp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#afdd7b5677e0e315c3c177d2dbe7cb7f7">bilinear_form</a> (const TestSpaceOp &amp;test_space_op, const <a class="el" href="classWeakForms_1_1Functor.html">Functor</a> &amp;functor_op, const TrialSpaceOp &amp;trial_space_op)</td></tr>
<tr class="separator:afdd7b5677e0e315c3c177d2dbe7cb7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30312909935a89c48022b69c1f309de"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename ScalarType , typename TrialSpaceOp , typename  = typename std::enable_if&lt;              !is_valid_form_functor&lt;ScalarType&gt;::value &amp;&amp;              is_scalar_type&lt;ScalarType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af30312909935a89c48022b69c1f309de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#af30312909935a89c48022b69c1f309de">bilinear_form</a> (const TestSpaceOp &amp;test_space_op, const ScalarType &amp;value, const TrialSpaceOp &amp;trial_space_op)</td></tr>
<tr class="separator:af30312909935a89c48022b69c1f309de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78136c6b281da64a8fa2a485261bfbec"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename TrialSpaceOp , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </td></tr>
<tr class="memitem:a78136c6b281da64a8fa2a485261bfbec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a78136c6b281da64a8fa2a485261bfbec">bilinear_form</a> (const TestSpaceOp &amp;test_space_op, const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;value, const TrialSpaceOp &amp;trial_space_op)</td></tr>
<tr class="separator:a78136c6b281da64a8fa2a485261bfbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa87ca80088ec1a1bcacf0a0e9bd7cce"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename TrialSpaceOp , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </td></tr>
<tr class="memitem:aaa87ca80088ec1a1bcacf0a0e9bd7cce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#aaa87ca80088ec1a1bcacf0a0e9bd7cce">bilinear_form</a> (const TestSpaceOp &amp;test_space_op, const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;value, const TrialSpaceOp &amp;trial_space_op)</td></tr>
<tr class="separator:aaa87ca80088ec1a1bcacf0a0e9bd7cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1def7786361fdb4f678d2aefda297d83"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename TrialSpaceOp &gt; </td></tr>
<tr class="memitem:a1def7786361fdb4f678d2aefda297d83"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a1def7786361fdb4f678d2aefda297d83">bilinear_form</a> (const TestSpaceOp &amp;test_space_op, const TrialSpaceOp &amp;trial_space_op)</td></tr>
<tr class="separator:a1def7786361fdb4f678d2aefda297d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7972c9f91c2f78a33eb88106b5eab156"><td class="memTemplParams" colspan="2">template&lt;typename... SymbolicOpsSubSpaceFieldSolution&gt; </td></tr>
<tr class="memitem:a7972c9f91c2f78a33eb88106b5eab156"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a>&lt; SymbolicOpsSubSpaceFieldSolution... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a7972c9f91c2f78a33eb88106b5eab156">energy_functor</a> (const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex, const SymbolicOpsSubSpaceFieldSolution &amp;...symbolic_op_field_solutions)</td></tr>
<tr class="separator:a7972c9f91c2f78a33eb88106b5eab156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aab0434f0dc6abdc1b1032a976fe272"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim, typename ScalarType &gt; </td></tr>
<tr class="memitem:a4aab0434f0dc6abdc1b1032a976fe272"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a4aab0434f0dc6abdc1b1032a976fe272">constant_scalar</a> (const ScalarType &amp;value, const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex)</td></tr>
<tr class="memdesc:a4aab0434f0dc6abdc1b1032a976fe272"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant scalar value upon evaluation.  <a href="namespaceWeakForms.html#a4aab0434f0dc6abdc1b1032a976fe272">More...</a><br /></td></tr>
<tr class="separator:a4aab0434f0dc6abdc1b1032a976fe272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438768963165239d8cb2156f787497a4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim, typename ScalarType &gt; </td></tr>
<tr class="memitem:a438768963165239d8cb2156f787497a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a438768963165239d8cb2156f787497a4">constant_scalar</a> (const ScalarType &amp;value)</td></tr>
<tr class="memdesc:a438768963165239d8cb2156f787497a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant scalar value upon evaluation.  <a href="namespaceWeakForms.html#a438768963165239d8cb2156f787497a4">More...</a><br /></td></tr>
<tr class="separator:a438768963165239d8cb2156f787497a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b985f4612cada863c97eff5804f427f"><td class="memTemplParams" colspan="2">template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:a9b985f4612cada863c97eff5804f427f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a9b985f4612cada863c97eff5804f427f">constant_tensor</a> (const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;value, const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex)</td></tr>
<tr class="memdesc:a9b985f4612cada863c97eff5804f427f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant tensor value upon evaluation.  <a href="namespaceWeakForms.html#a9b985f4612cada863c97eff5804f427f">More...</a><br /></td></tr>
<tr class="separator:a9b985f4612cada863c97eff5804f427f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0881a8be1b214a167b49a4086b8d12"><td class="memTemplParams" colspan="2">template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:a0b0881a8be1b214a167b49a4086b8d12"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a0b0881a8be1b214a167b49a4086b8d12">constant_tensor</a> (const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;value)</td></tr>
<tr class="memdesc:a0b0881a8be1b214a167b49a4086b8d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant tensor value upon evaluation.  <a href="namespaceWeakForms.html#a0b0881a8be1b214a167b49a4086b8d12">More...</a><br /></td></tr>
<tr class="separator:a0b0881a8be1b214a167b49a4086b8d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b919bc91e1d9204c2c25b5e46abd64"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:a62b919bc91e1d9204c2c25b5e46abd64"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a62b919bc91e1d9204c2c25b5e46abd64">constant_vector</a> (const Tensor&lt; 1, spacedim, ScalarType &gt; &amp;value, const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex)</td></tr>
<tr class="memdesc:a62b919bc91e1d9204c2c25b5e46abd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant vector (rank-1 tensor) value upon evaluation.  <a href="namespaceWeakForms.html#a62b919bc91e1d9204c2c25b5e46abd64">More...</a><br /></td></tr>
<tr class="separator:a62b919bc91e1d9204c2c25b5e46abd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc1a23ded2d0b676dbc7f0771a62603"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:a3cc1a23ded2d0b676dbc7f0771a62603"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a3cc1a23ded2d0b676dbc7f0771a62603">constant_vector</a> (const Tensor&lt; 1, spacedim, ScalarType &gt; &amp;value)</td></tr>
<tr class="memdesc:a3cc1a23ded2d0b676dbc7f0771a62603"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant vector (rank-1 tensor) value upon evaluation.  <a href="namespaceWeakForms.html#a3cc1a23ded2d0b676dbc7f0771a62603">More...</a><br /></td></tr>
<tr class="separator:a3cc1a23ded2d0b676dbc7f0771a62603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c9fa89a4ce12793236437a8b314dfb"><td class="memTemplParams" colspan="2">template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:ac8c9fa89a4ce12793236437a8b314dfb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#ac8c9fa89a4ce12793236437a8b314dfb">constant_symmetric_tensor</a> (const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;value, const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex)</td></tr>
<tr class="memdesc:ac8c9fa89a4ce12793236437a8b314dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant symmetric tensor value upon evaluation.  <a href="namespaceWeakForms.html#ac8c9fa89a4ce12793236437a8b314dfb">More...</a><br /></td></tr>
<tr class="separator:ac8c9fa89a4ce12793236437a8b314dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de8c9d6bf9ce8ab1f30f169202855e9"><td class="memTemplParams" colspan="2">template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:a5de8c9d6bf9ce8ab1f30f169202855e9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a5de8c9d6bf9ce8ab1f30f169202855e9">constant_symmetric_tensor</a> (const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;value)</td></tr>
<tr class="memdesc:a5de8c9d6bf9ce8ab1f30f169202855e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant symmetric tensor value upon evaluation.  <a href="namespaceWeakForms.html#a5de8c9d6bf9ce8ab1f30f169202855e9">More...</a><br /></td></tr>
<tr class="separator:a5de8c9d6bf9ce8ab1f30f169202855e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7da85d217255f157eddcd2a40ee570"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename Functor , typename  = typename std::enable_if&lt;is_valid_form_functor&lt;Functor&gt;::value &amp;&amp;                                       !is_scalar_type&lt;Functor&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a7b7da85d217255f157eddcd2a40ee570"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1LinearForm.html">LinearForm</a>&lt; TestSpaceOp, <a class="el" href="classWeakForms_1_1Functor.html">Functor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a7b7da85d217255f157eddcd2a40ee570">linear_form</a> (const TestSpaceOp &amp;test_space_op, const <a class="el" href="classWeakForms_1_1Functor.html">Functor</a> &amp;functor_op)</td></tr>
<tr class="separator:a7b7da85d217255f157eddcd2a40ee570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee40ff51bb5da73a4e19819b40adf9a"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename ScalarType , typename  = typename std::enable_if&lt;              !is_valid_form_functor&lt;ScalarType&gt;::value &amp;&amp;              is_scalar_type&lt;ScalarType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afee40ff51bb5da73a4e19819b40adf9a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#afee40ff51bb5da73a4e19819b40adf9a">linear_form</a> (const TestSpaceOp &amp;test_space_op, const ScalarType &amp;value)</td></tr>
<tr class="separator:afee40ff51bb5da73a4e19819b40adf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b18995abdd2d8eb0f1d82793433d515"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </td></tr>
<tr class="memitem:a2b18995abdd2d8eb0f1d82793433d515"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a2b18995abdd2d8eb0f1d82793433d515">linear_form</a> (const TestSpaceOp &amp;test_space_op, const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;value)</td></tr>
<tr class="separator:a2b18995abdd2d8eb0f1d82793433d515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4497dc77582f8f26dcd908b333a8aae0"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </td></tr>
<tr class="memitem:a4497dc77582f8f26dcd908b333a8aae0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a4497dc77582f8f26dcd908b333a8aae0">linear_form</a> (const TestSpaceOp &amp;test_space_op, const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;value)</td></tr>
<tr class="separator:a4497dc77582f8f26dcd908b333a8aae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b1f385584348c61cedf4a1092de1fc"><td class="memTemplParams" colspan="2">template&lt;typename... SymbolicOpsSubSpaceFieldSolution&gt; </td></tr>
<tr class="memitem:ad1b1f385584348c61cedf4a1092de1fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1ResidualFunctor.html">ResidualFunctor</a>&lt; SymbolicOpsSubSpaceFieldSolution... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#ad1b1f385584348c61cedf4a1092de1fc">residual_functor</a> (const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex, const SymbolicOpsSubSpaceFieldSolution &amp;...symbolic_op_field_solutions)</td></tr>
<tr class="separator:ad1b1f385584348c61cedf4a1092de1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d11b9bc21b0f17dac3f1b2595e135b"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename... SymbolicOpsSubSpaceFieldSolution&gt; </td></tr>
<tr class="memitem:af1d11b9bc21b0f17dac3f1b2595e135b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a>&lt; SymbolicOpsSubSpaceFieldSolution... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#af1d11b9bc21b0f17dac3f1b2595e135b">residual_view_functor</a> (const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex, const TestSpaceOp &amp;test_space_op, const SymbolicOpsSubSpaceFieldSolution &amp;...symbolic_op_field_solutions)</td></tr>
<tr class="separator:af1d11b9bc21b0f17dac3f1b2595e135b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829718a6fa9f0bf9bc149b3d7cc636e5"><td class="memTemplParams" colspan="2">template&lt;typename EnergyFunctor , typename  = typename std::enable_if&lt;              is_energy_functor_op&lt;EnergyFunctor&gt;::value &amp;&amp;              (is_ad_functor_op&lt;EnergyFunctor&gt;::value ||               is_sd_functor_op&lt;EnergyFunctor&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a829718a6fa9f0bf9bc149b3d7cc636e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1SelfLinearization_1_1EnergyFunctional.html">SelfLinearization::EnergyFunctional</a>&lt; <a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a829718a6fa9f0bf9bc149b3d7cc636e5">energy_functional_form</a> (const <a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a> &amp;functor_op)</td></tr>
<tr class="separator:a829718a6fa9f0bf9bc149b3d7cc636e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c199a2a4058afb1c4f76e7a03bb6d97"><td class="memTemplParams" colspan="2">template&lt;typename ResidualViewFunctor , typename  = typename std::enable_if&lt;              is_residual_functor_op&lt;ResidualViewFunctor&gt;::value &amp;&amp;              (is_ad_functor_op&lt;ResidualViewFunctor&gt;::value ||               is_sd_functor_op&lt;ResidualViewFunctor&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a6c199a2a4058afb1c4f76e7a03bb6d97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1SelfLinearization_1_1ResidualView.html">SelfLinearization::ResidualView</a>&lt; <a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a6c199a2a4058afb1c4f76e7a03bb6d97">residual_form</a> (const <a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a> &amp;functor_op)</td></tr>
<tr class="separator:a6c199a2a4058afb1c4f76e7a03bb6d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892dd380ef93823647570cdfb03d98db"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType  = double, typename Integrand , typename IntegralType , typename  = typename std::enable_if&lt;is_valid_integration_domain&lt;              typename std::decay&lt;IntegralType&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a892dd380ef93823647570cdfb03d98db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a892dd380ef93823647570cdfb03d98db">integrate</a> (const Integrand &amp;integrand, const IntegralType &amp;integral)</td></tr>
<tr class="memdesc:a892dd380ef93823647570cdfb03d98db"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that returns an operator that represents an integral operation.  <a href="namespaceWeakForms.html#a892dd380ef93823647570cdfb03d98db">More...</a><br /></td></tr>
<tr class="separator:a892dd380ef93823647570cdfb03d98db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0a9c531383d9c68277a50599e3e9f565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9c531383d9c68277a50599e3e9f565">&#9670;&nbsp;</a></span>VectorCacheFunctor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceWeakForms.html#a0a9c531383d9c68277a50599e3e9f565">WeakForms::VectorCacheFunctor</a> = typedef <a class="el" href="classWeakForms_1_1TensorCacheFunctor.html">TensorCacheFunctor</a>&lt;1, dim&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias for a cached functor that returns vector (i.e. rank-1 tensor) values upon evaluation. </p>

<p class="definition">Definition at line <a class="el" href="cache__functors_8h_source.html#l00291">291</a> of file <a class="el" href="cache__functors_8h_source.html">cache_functors.h</a>.</p>

</div>
</div>
<a id="a69e444116cbcbd5ccf773acddc015de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e444116cbcbd5ccf773acddc015de6">&#9670;&nbsp;</a></span>VectorFunctor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceWeakForms.html#a69e444116cbcbd5ccf773acddc015de6">WeakForms::VectorFunctor</a> = typedef <a class="el" href="classWeakForms_1_1TensorFunctor.html">TensorFunctor</a>&lt;1, dim&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias for a functor that returns vector (i.e. rank-1 tensor) values upon evaluation.</p>
<p>An example of usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> VectorFunctor&lt;spacedim&gt; v1(<span class="stringliteral">&quot;v1&quot;</span>, <span class="stringliteral">&quot;v1&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> vf1 = v1.template value&lt;double, spacedim&gt;(</div>
<div class="line">  [](<span class="keyword">const</span> FEValuesBase&lt;dim, spacedim&gt; &amp;, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)</div>
<div class="line">  { <span class="keywordflow">return</span> Tensor&lt;1, dim, double&gt;{}; });</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="functors_8h_source.html#l00529">529</a> of file <a class="el" href="functors_8h_source.html">functors.h</a>.</p>

</div>
</div>
<a id="a76a4e449c6edab12a90df92459fae2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a4e449c6edab12a90df92459fae2d6">&#9670;&nbsp;</a></span>VectorFunctionFunctor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceWeakForms.html#a76a4e449c6edab12a90df92459fae2d6">WeakForms::VectorFunctionFunctor</a> = typedef <a class="el" href="classWeakForms_1_1TensorFunctionFunctor.html">TensorFunctionFunctor</a>&lt;1, dim&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias for a functor that wraps a rank-1 deal.II tensor function.</p>
<p>An example of usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> VectorFunctionFunctor&lt;spacedim&gt; v1(<span class="stringliteral">&quot;v1&quot;</span>, <span class="stringliteral">&quot;v1&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> ConstantTensorFunction&lt;1, dim, double&gt; constant_tensor_function_1(</div>
<div class="line">  Tensor&lt;1, dim, double&gt;{});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Function value</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> vf1 = v1.template <a class="code" href="namespaceWeakForms_1_1Operators.html#aec4fa4a0321d7d1b75b1dd94ae07a48ba2063c1608d6e0baf80249c42e2be5804">value</a>&lt;double,</div>
<div class="line">                                   dim&gt;(constant_tensor_function_1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Function gradient</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> gvf1 = v1.template <a class="code" href="namespaceWeakForms_1_1Operators.html#aec4fa4a0321d7d1b75b1dd94ae07a48bae2b6dfb8a5c48206992d8310d176c37c">gradient</a>&lt;double,</div>
<div class="line">                                       dim&gt;(constant_tensor_function_1);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="functors_8h_source.html#l00552">552</a> of file <a class="el" href="functors_8h_source.html">functors.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acaa0a4172ad5893b342da4aae68fb3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa0a4172ad5893b342da4aae68fb3a4">&#9670;&nbsp;</a></span>BilinearFormComponentFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">WeakForms::BilinearFormComponentFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A set of filters that are applied during the assembly process for bilinear forms.</p>
<p>These filters are used to skip some assembly contributions, or to extract certain components of vectorial or tensorial shape functions. To understand what these filters are to do, it is helpful to first define some notation:</p><ul>
<li><code>I</code> and <code>J</code> refer to the local degree of freedom indices respectively associated with the test and trial shape functions.</li>
<li><code>component_i</code> and <code>component_j</code> are, respectively, the index of the <code>I</code>th and <code>J</code>th shape functions within the finite element (system). The component of the <code>K</code>th shape function would correspond to <code>finite_element.system_to_component_index(K).first;</code></li>
<li><code>multiplicity_I</code> and <code>multiplicity_J</code> are, respectively, the copy of the base finite element within the finite element (system) that corresponds with the <code>I</code>th and <code>J</code>th degree of freedom. The multiplicity of the <code>K</code>th shape function is the equivalent to what is returned by <code>finite_element.system_to_base_index(K).first.second;</code>.</li>
</ul>
<p>Also refer to the introduction of the deal.II <a href="https://dealii.org/developer/doxygen/deal.II/classFiniteElement.html">FiniteElement</a> class for further insights. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a34c4dedca0d31e298e5fb97dd7f47a96"></a>form_components_default&#160;</td><td class="fielddoc"><p>Apply no filters.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this filter alone results in optimum performance code being executed by the assembler. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a54ecd6b612d5386ff36b545c081c2c1d"></a>multiplicity_I&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. fully evaluated shape function operator), extract its "multiplicity index" component that is associated with the <code>I</code>th local shape function.</p>
<dl class="section note"><dt>Note</dt><dd>This extraction operation always occurs in preference to others. So if it is combined with other filters acting on index <code>I</code>, then the extraction of this component of the (tensorial) shape function operation result will happen first. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a52eda1df3a1fe00eb1fbc8d4693c8f7d"></a>multiplicity_J&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. fully evaluated shape function operator), extract its "multiplicity index" component that is associated with the <code>J</code>th local shape function.</p>
<dl class="section note"><dt>Note</dt><dd>This extraction operation always occurs in preference to others. So if it is combined with other filters acting on index <code>J</code>, then the extraction of this component of the (tensorial) shape function operation result will happen first. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a8a40a6051a8a98cff6d5395cef34e94e"></a>dof_I_component_i&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. the fully evaluated test shape function operator), extract its "component index" component that is associated with the <code>I</code>th local shape function. This is the equivalent of computing the inner product \( \left[ \bullet \right]^{I} \cdot \mathbf{e}_{i} \) where \( \left[ \bullet \right]^{I} \) denotes the qualified test shape function operator and \( \mathbf{e}_{i} \) is the \( i \)th Cartesian coordinate direction.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this filter will result in a slight performance penalty, as it will inhibit certain optimisations from being performed during the assembly process.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called if all shape functions in the finite element (system) are primitive. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4acc3c6969be48c9763f101891745480e6"></a>dof_I_component_j&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. the fully evaluated test shape function operator), extract its "component index" component that is associated with the <code>J</code>th local shape function. This is the equivalent of computing the inner product \( \left[ \bullet \right]^{I} \cdot \mathbf{e}_{j} \) where \( \left[ \bullet \right]^{I} \) denotes the qualified test shape function operator and \( \mathbf{e}_{j} \) is the \( j \)th Cartesian coordinate direction.</p>
<p>Notice that, for this filter, there is a cross-indexing of the shape function operator and the component that is to be extracted.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this filter will result in a slight performance penalty, as it will inhibit certain optimisations from being performed during the assembly process.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called if all shape functions in the finite element (system) are primitive. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a8d56c5d28292ad64b0978eda61d01e73"></a>dof_J_component_i&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. the fully evaluated trial shape function operator), extract its "component index" component that is associated with the <code>I</code>th local shape function. This is the equivalent of computing the inner product \( \left[ \bullet \right]^{J} \cdot \mathbf{e}_{i} \) where \( \left[ \bullet \right]^{J} \) denotes the qualified trial shape function operator and \( \mathbf{e}_{i} \) is the \( i \)th Cartesian coordinate direction.</p>
<p>Notice that, for this filter, there is a cross-indexing of the shape function operator and the component that is to be extracted.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this filter will result in a slight performance penalty, as it will inhibit certain optimisations from being performed during the assembly process.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called if all shape functions in the finite element (system) are primitive. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4ab22689254b0cc55000ab2509c90efcce"></a>dof_J_component_j&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. the fully evaluated trial shape function operator), extract its "component index" component that is associated with the <code>J</code>th local shape function. This is the equivalent of computing the inner product \( \left[ \bullet \right]^{J} \cdot \mathbf{e}_{j} \) where \( \left[ \bullet \right]^{J} \) denotes the qualified trial shape function operator and \( \mathbf{e}_{j} \) is the \( j \)th Cartesian coordinate direction.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this filter will result in a slight performance penalty, as it will inhibit certain optimisations from being performed during the assembly process.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called if all shape functions in the finite element (system) are primitive. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a286506621645e37af87ab00331615d9b"></a>local_shape_function_kronecker_delta&#160;</td><td class="fielddoc"><p>Skip all contributions for which the shape function component is not equal for <code>component_i</code> and <code>component_j</code> of the <code>I</code>th and <code>J</code>th degrees of freedom. That is to say, that the associated Cartesian coordinate directions \( \mathbf{e}_{i} \) and \( \mathbf{e}_{j} \) are identical.</p>
<dl class="section note"><dt>Note</dt><dd>If used in isolation, then use of this filter still results in optimum performance code being executed by the assembler. </dd></dl>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00063">63</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a36e97adeeaa7ab0ed216e0587a70080c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e97adeeaa7ab0ed216e0587a70080c">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> WeakForms::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00186">186</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="a320830063be57b317a00c519cb979e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320830063be57b317a00c519cb979e04">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&amp; WeakForms::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00194">194</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="a7d14de582aceac693625e252b461da59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d14de582aceac693625e252b461da59">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> WeakForms::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00202">202</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="a0d1086e3a3e67706edcefd70e630050b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1086e3a3e67706edcefd70e630050b">&#9670;&nbsp;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&amp; WeakForms::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00210">210</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="afdd7b5677e0e315c3c177d2dbe7cb7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd7b5677e0e315c3c177d2dbe7cb7f7">&#9670;&nbsp;</a></span>bilinear_form() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TestSpaceOp , typename Functor , typename TrialSpaceOp , typename  = typename std::enable_if&lt;is_valid_form_functor&lt;Functor&gt;::value &amp;&amp;                                       !is_scalar_type&lt;Functor&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeakForms_1_1BilinearForm.html">BilinearForm</a>&lt;TestSpaceOp, <a class="el" href="classWeakForms_1_1Functor.html">Functor</a>, TrialSpaceOp&gt; WeakForms::bilinear_form </td>
          <td>(</td>
          <td class="paramtype">const TestSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>test_space_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWeakForms_1_1Functor.html">Functor</a> &amp;&#160;</td>
          <td class="paramname"><em>functor_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrialSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>trial_space_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00638">638</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="af30312909935a89c48022b69c1f309de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30312909935a89c48022b69c1f309de">&#9670;&nbsp;</a></span>bilinear_form() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TestSpaceOp , typename ScalarType , typename TrialSpaceOp , typename  = typename std::enable_if&lt;              !is_valid_form_functor&lt;ScalarType&gt;::value &amp;&amp;              is_scalar_type&lt;ScalarType&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::bilinear_form </td>
          <td>(</td>
          <td class="paramtype">const TestSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>test_space_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrialSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>trial_space_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00655">655</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="a78136c6b281da64a8fa2a485261bfbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78136c6b281da64a8fa2a485261bfbec">&#9670;&nbsp;</a></span>bilinear_form() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename TrialSpaceOp , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::bilinear_form </td>
          <td>(</td>
          <td class="paramtype">const TestSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>test_space_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrialSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>trial_space_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00675">675</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="aaa87ca80088ec1a1bcacf0a0e9bd7cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa87ca80088ec1a1bcacf0a0e9bd7cce">&#9670;&nbsp;</a></span>bilinear_form() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename TrialSpaceOp , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::bilinear_form </td>
          <td>(</td>
          <td class="paramtype">const TestSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>test_space_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrialSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>trial_space_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00694">694</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="a1def7786361fdb4f678d2aefda297d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1def7786361fdb4f678d2aefda297d83">&#9670;&nbsp;</a></span>bilinear_form() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TestSpaceOp , typename TrialSpaceOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::bilinear_form </td>
          <td>(</td>
          <td class="paramtype">const TestSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>test_space_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrialSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>trial_space_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00710">710</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="a7972c9f91c2f78a33eb88106b5eab156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7972c9f91c2f78a33eb88106b5eab156">&#9670;&nbsp;</a></span>energy_functor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... SymbolicOpsSubSpaceFieldSolution&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a>&lt;SymbolicOpsSubSpaceFieldSolution...&gt; WeakForms::energy_functor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_ascii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_latex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SymbolicOpsSubSpaceFieldSolution &amp;...&#160;</td>
          <td class="paramname"><em>symbolic_op_field_solutions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shortcut so that we don't need to do something like this:</p>
<p><code> const FieldSolution&lt;dim&gt; solution; const <a class="el" href="structWeakForms_1_1SubSpaceExtractors_1_1Scalar.html" title="An object that can be used to extract a scalar subspace from a global finite element space.">WeakForms::SubSpaceExtractors::Scalar</a> subspace_extractor(0, "s", "s");</code></p>
<p><code>const auto soln_ss = solution[subspace_extractor]; const auto soln_val = soln_ss.value(); // Solution value const auto soln_grad = soln_ss.gradient(); // Solution gradient ...</code></p>
<p><code>const EnergyFunctor&lt;decltype(soln_val), decltype(soln_grad), ...&gt; energy("e", "\\Psi", soln_val, soln_grad, ...); </code> </p>

<p class="definition">Definition at line <a class="el" href="energy__functor_8h_source.html#l00453">453</a> of file <a class="el" href="energy__functor_8h_source.html">energy_functor.h</a>.</p>

</div>
</div>
<a id="a4aab0434f0dc6abdc1b1032a976fe272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aab0434f0dc6abdc1b1032a976fe272">&#9670;&nbsp;</a></span>constant_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::constant_scalar </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_ascii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_latex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function that always returns the same constant scalar value upon evaluation. </p>
<p>This variation allows one to prescribe the value, as well as the ASCII and LaTeX representation of the value.</p>
<p>An example of usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> i =</div>
<div class="line">  constant_scalar&lt;dim&gt;(std::complex&lt;double&gt;{0, 1}, <span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;i&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension in which the scalar is being evaluated. </td></tr>
    <tr><td class="paramname">spacedim</td><td>The spatial dimension in which the scalar is being evaluated. </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The underlying scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be returned upon evaluation. </td></tr>
    <tr><td class="paramname">symbol_ascii</td><td>The ASCII representation of the value. </td></tr>
    <tr><td class="paramname">symbol_latex</td><td>The LaTeX representation of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto Returns a symbolic operator based on a <a class="el" href="classWeakForms_1_1ScalarFunctor.html" title="A functor that returns scalar values upon evaluation.">ScalarFunctor</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="functors_8h_source.html#l01345">1345</a> of file <a class="el" href="functors_8h_source.html">functors.h</a>.</p>

</div>
</div>
<a id="a438768963165239d8cb2156f787497a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438768963165239d8cb2156f787497a4">&#9670;&nbsp;</a></span>constant_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::constant_scalar </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function that always returns the same constant scalar value upon evaluation. </p>
<p>This variation allows one to prescribe only the value; the ASCII and LaTeX representations exactly match the value itself.</p>
<p>An example of usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> s = constant_scalar&lt;dim&gt;(1.0);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension in which the scalar is being evaluated. </td></tr>
    <tr><td class="paramname">spacedim</td><td>The spatial dimension in which the scalar is being evaluated. </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The underlying scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be returned upon evaluation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto Returns a symbolic operator based on a <a class="el" href="classWeakForms_1_1ScalarFunctor.html" title="A functor that returns scalar values upon evaluation.">ScalarFunctor</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="functors_8h_source.html#l01380">1380</a> of file <a class="el" href="functors_8h_source.html">functors.h</a>.</p>

</div>
</div>
<a id="a9b985f4612cada863c97eff5804f427f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b985f4612cada863c97eff5804f427f">&#9670;&nbsp;</a></span>constant_tensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::constant_tensor </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_ascii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_latex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function that always returns the same constant tensor value upon evaluation. </p>
<p>This variation allows one to prescribe the value, as well as the ASCII and LaTeX representation of the tensor.</p>
<p>An example of usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> T = constant_tensor&lt;dim&gt;(Tensor&lt;2, dim&gt;{}, <span class="stringliteral">&quot;T&quot;</span>, <span class="stringliteral">&quot;T&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">rank</td><td>The rank of the tensor that is returned upon evaluation. </td></tr>
    <tr><td class="paramname">spacedim</td><td>The spatial dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The underlying scalar type for each component of the tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be returned upon evaluation. </td></tr>
    <tr><td class="paramname">symbol_ascii</td><td>The ASCII representation of the tensor. </td></tr>
    <tr><td class="paramname">symbol_latex</td><td>The LaTeX representation of the tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto Returns a symbolic operator based on a <a class="el" href="classWeakForms_1_1TensorFunctor.html" title="A functor that returns a tensor upon evaluation.">TensorFunctor</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="functors_8h_source.html#l01413">1413</a> of file <a class="el" href="functors_8h_source.html">functors.h</a>.</p>

</div>
</div>
<a id="a0b0881a8be1b214a167b49a4086b8d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0881a8be1b214a167b49a4086b8d12">&#9670;&nbsp;</a></span>constant_tensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::constant_tensor </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function that always returns the same constant tensor value upon evaluation. </p>
<p>This variation allows one to prescribe only the values of the tensor components; the ASCII and LaTeX representations are a flattened representation of the tensor.</p>
<p>An example of usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> T = constant_tensor&lt;dim&gt;(Tensor&lt;2, dim&gt;{});</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">rank</td><td>The rank of the tensor that is returned upon evaluation. </td></tr>
    <tr><td class="paramname">spacedim</td><td>The spatial dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The underlying scalar type for each component of the tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be returned upon evaluation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto Returns a symbolic operator based on a <a class="el" href="classWeakForms_1_1TensorFunctor.html" title="A functor that returns a tensor upon evaluation.">TensorFunctor</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="functors_8h_source.html#l01450">1450</a> of file <a class="el" href="functors_8h_source.html">functors.h</a>.</p>

</div>
</div>
<a id="a62b919bc91e1d9204c2c25b5e46abd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b919bc91e1d9204c2c25b5e46abd64">&#9670;&nbsp;</a></span>constant_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::constant_vector </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; 1, spacedim, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_ascii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_latex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function that always returns the same constant vector (rank-1 tensor) value upon evaluation. </p>
<p>This variation allows one to prescribe the value, as well as the ASCII and LaTeX representation of the vector.</p>
<p>An example of usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v = constant_vector&lt;dim&gt;(Tensor&lt;1, dim&gt;(), <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">spacedim</td><td>The spatial dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The underlying scalar type for each component of the tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be returned upon evaluation. </td></tr>
    <tr><td class="paramname">symbol_ascii</td><td>The ASCII representation of the vector. </td></tr>
    <tr><td class="paramname">symbol_latex</td><td>The LaTeX representation of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto Returns a symbolic operator based on a rank-1 <a class="el" href="classWeakForms_1_1TensorFunctor.html" title="A functor that returns a tensor upon evaluation.">TensorFunctor</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="functors_8h_source.html#l01483">1483</a> of file <a class="el" href="functors_8h_source.html">functors.h</a>.</p>

</div>
</div>
<a id="a3cc1a23ded2d0b676dbc7f0771a62603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc1a23ded2d0b676dbc7f0771a62603">&#9670;&nbsp;</a></span>constant_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::constant_vector </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; 1, spacedim, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function that always returns the same constant vector (rank-1 tensor) value upon evaluation. </p>
<p>This variation allows one to prescribe only the values of the vector components; the ASCII and LaTeX representations are a flattened representation of the vector.</p>
<p>An example of usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v = constant_vector&lt;dim&gt;(Tensor&lt;1, dim&gt;());</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">spacedim</td><td>The spatial dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The underlying scalar type for each component of the tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be returned upon evaluation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto Returns a symbolic operator based on a rank-1 <a class="el" href="classWeakForms_1_1TensorFunctor.html" title="A functor that returns a tensor upon evaluation.">TensorFunctor</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="functors_8h_source.html#l01513">1513</a> of file <a class="el" href="functors_8h_source.html">functors.h</a>.</p>

</div>
</div>
<a id="ac8c9fa89a4ce12793236437a8b314dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c9fa89a4ce12793236437a8b314dfb">&#9670;&nbsp;</a></span>constant_symmetric_tensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::constant_symmetric_tensor </td>
          <td>(</td>
          <td class="paramtype">const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_ascii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_latex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function that always returns the same constant symmetric tensor value upon evaluation. </p>
<p>This variation allows one to prescribe the value, as well as the ASCII and LaTeX representation of the symmetric tensor.</p>
<p>An example of usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S2 = constant_symmetric_tensor&lt;dim&gt;(</div>
<div class="line">  unit_symmetric_tensor&lt;dim&gt;(), <span class="stringliteral">&quot;S&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">rank</td><td>The rank of the symmetric tensor that is returned upon evaluation. </td></tr>
    <tr><td class="paramname">spacedim</td><td>The spatial dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The underlying scalar type for each component of the tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be returned upon evaluation. </td></tr>
    <tr><td class="paramname">symbol_ascii</td><td>The ASCII representation of the tensor. </td></tr>
    <tr><td class="paramname">symbol_latex</td><td>The LaTeX representation of the tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto Returns a symbolic operator based on a <a class="el" href="classWeakForms_1_1SymmetricTensorFunctor.html" title="A functor that returns a symmetric tensor upon evaluation.">SymmetricTensorFunctor</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="functors_8h_source.html#l01544">1544</a> of file <a class="el" href="functors_8h_source.html">functors.h</a>.</p>

</div>
</div>
<a id="a5de8c9d6bf9ce8ab1f30f169202855e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de8c9d6bf9ce8ab1f30f169202855e9">&#9670;&nbsp;</a></span>constant_symmetric_tensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::constant_symmetric_tensor </td>
          <td>(</td>
          <td class="paramtype">const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function that always returns the same constant symmetric tensor value upon evaluation. </p>
<p>This variation allows one to prescribe only the values of the symmetric tensor components; the ASCII and LaTeX representations are a flattened representation of the symmetric tensor.</p>
<p>An example of usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S4 = constant_symmetric_tensor&lt;dim&gt;(identity_tensor&lt;dim&gt;());</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">rank</td><td>The rank of the symmetric tensor that is returned upon evaluation. </td></tr>
    <tr><td class="paramname">spacedim</td><td>The spatial dimension in which the tensor is being evaluated. </td></tr>
    <tr><td class="paramname">ScalarType</td><td>The underlying scalar type for each component of the tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be returned upon evaluation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto Returns a symbolic operator based on a <a class="el" href="classWeakForms_1_1SymmetricTensorFunctor.html" title="A functor that returns a symmetric tensor upon evaluation.">SymmetricTensorFunctor</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="functors_8h_source.html#l01583">1583</a> of file <a class="el" href="functors_8h_source.html">functors.h</a>.</p>

</div>
</div>
<a id="a7b7da85d217255f157eddcd2a40ee570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7da85d217255f157eddcd2a40ee570">&#9670;&nbsp;</a></span>linear_form() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TestSpaceOp , typename Functor , typename  = typename std::enable_if&lt;is_valid_form_functor&lt;Functor&gt;::value &amp;&amp;                                       !is_scalar_type&lt;Functor&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeakForms_1_1LinearForm.html">LinearForm</a>&lt;TestSpaceOp, <a class="el" href="classWeakForms_1_1Functor.html">Functor</a>&gt; WeakForms::linear_form </td>
          <td>(</td>
          <td class="paramtype">const TestSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>test_space_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWeakForms_1_1Functor.html">Functor</a> &amp;&#160;</td>
          <td class="paramname"><em>functor_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__forms_8h_source.html#l00226">226</a> of file <a class="el" href="linear__forms_8h_source.html">linear_forms.h</a>.</p>

</div>
</div>
<a id="afee40ff51bb5da73a4e19819b40adf9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee40ff51bb5da73a4e19819b40adf9a">&#9670;&nbsp;</a></span>linear_form() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TestSpaceOp , typename ScalarType , typename  = typename std::enable_if&lt;              !is_valid_form_functor&lt;ScalarType&gt;::value &amp;&amp;              is_scalar_type&lt;ScalarType&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::linear_form </td>
          <td>(</td>
          <td class="paramtype">const TestSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>test_space_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__forms_8h_source.html#l00238">238</a> of file <a class="el" href="linear__forms_8h_source.html">linear_forms.h</a>.</p>

</div>
</div>
<a id="a2b18995abdd2d8eb0f1d82793433d515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b18995abdd2d8eb0f1d82793433d515">&#9670;&nbsp;</a></span>linear_form() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::linear_form </td>
          <td>(</td>
          <td class="paramtype">const TestSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>test_space_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__forms_8h_source.html#l00253">253</a> of file <a class="el" href="linear__forms_8h_source.html">linear_forms.h</a>.</p>

</div>
</div>
<a id="a4497dc77582f8f26dcd908b333a8aae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4497dc77582f8f26dcd908b333a8aae0">&#9670;&nbsp;</a></span>linear_form() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::linear_form </td>
          <td>(</td>
          <td class="paramtype">const TestSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>test_space_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__forms_8h_source.html#l00268">268</a> of file <a class="el" href="linear__forms_8h_source.html">linear_forms.h</a>.</p>

</div>
</div>
<a id="ad1b1f385584348c61cedf4a1092de1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b1f385584348c61cedf4a1092de1fc">&#9670;&nbsp;</a></span>residual_functor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... SymbolicOpsSubSpaceFieldSolution&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeakForms_1_1ResidualFunctor.html">ResidualFunctor</a>&lt;SymbolicOpsSubSpaceFieldSolution...&gt; WeakForms::residual_functor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_ascii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_latex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SymbolicOpsSubSpaceFieldSolution &amp;...&#160;</td>
          <td class="paramname"><em>symbolic_op_field_solutions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for create a <a class="el" href="classWeakForms_1_1ResidualFunctor.html">ResidualFunctor</a>.</p>
<p>It is, essentially, a shortcut so that we don't need to do something like this:</p>
<p><code> const FieldSolution&lt;dim&gt; solution; const <a class="el" href="structWeakForms_1_1SubSpaceExtractors_1_1Scalar.html" title="An object that can be used to extract a scalar subspace from a global finite element space.">WeakForms::SubSpaceExtractors::Scalar</a> subspace_extractor(0, "s", "s");</code></p>
<p><code>const auto soln_ss = solution[subspace_extractor]; const auto soln_val = soln_ss.value(); // Solution value const auto soln_grad = soln_ss.gradient(); // Solution gradient ...</code></p>
<p><code>const ResidualFunctor&lt;decltype(soln_val), decltype(soln_grad), ...&gt; residual("R", "R", soln_val, soln_grad, ...); </code> </p>

<p class="definition">Definition at line <a class="el" href="residual__functor_8h_source.html#l00639">639</a> of file <a class="el" href="residual__functor_8h_source.html">residual_functor.h</a>.</p>

</div>
</div>
<a id="af1d11b9bc21b0f17dac3f1b2595e135b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d11b9bc21b0f17dac3f1b2595e135b">&#9670;&nbsp;</a></span>residual_view_functor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TestSpaceOp , typename... SymbolicOpsSubSpaceFieldSolution&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a>&lt;SymbolicOpsSubSpaceFieldSolution...&gt; WeakForms::residual_view_functor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_ascii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_latex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TestSpaceOp &amp;&#160;</td>
          <td class="paramname"><em>test_space_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SymbolicOpsSubSpaceFieldSolution &amp;...&#160;</td>
          <td class="paramname"><em>symbolic_op_field_solutions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for create a <a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a>. </p>

<p class="definition">Definition at line <a class="el" href="residual__functor_8h_source.html#l00654">654</a> of file <a class="el" href="residual__functor_8h_source.html">residual_functor.h</a>.</p>

</div>
</div>
<a id="a829718a6fa9f0bf9bc149b3d7cc636e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829718a6fa9f0bf9bc149b3d7cc636e5">&#9670;&nbsp;</a></span>energy_functional_form()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnergyFunctor , typename  = typename std::enable_if&lt;              is_energy_functor_op&lt;EnergyFunctor&gt;::value &amp;&amp;              (is_ad_functor_op&lt;EnergyFunctor&gt;::value ||               is_sd_functor_op&lt;EnergyFunctor&gt;::value)&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeakForms_1_1SelfLinearization_1_1EnergyFunctional.html">SelfLinearization::EnergyFunctional</a>&lt;<a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a>&gt; WeakForms::energy_functional_form </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a> &amp;&#160;</td>
          <td class="paramname"><em>functor_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function that generates a self-linearizing energy functional form from an energy functor.</p>
<p>For more information about the self-linearizing form that is created, please refer to the documentation of the <a class="el" href="classWeakForms_1_1SelfLinearization_1_1EnergyFunctional.html">SelfLinearization::EnergyFunctional</a> class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a></td><td>A class that is recognised to be a energy functor operation, as well as a functor that is either AD compatible SD compatible (i.e. can exploit either automatic or symbolic differentiation). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor_op</td><td>An energy functor that is to be converted to a form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SelfLinearization::EnergyFunctional&lt;EnergyFunctor&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="self__linearizing__forms_8h_source.html#l01531">1531</a> of file <a class="el" href="self__linearizing__forms_8h_source.html">self_linearizing_forms.h</a>.</p>

</div>
</div>
<a id="a6c199a2a4058afb1c4f76e7a03bb6d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c199a2a4058afb1c4f76e7a03bb6d97">&#9670;&nbsp;</a></span>residual_form()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResidualViewFunctor , typename  = typename std::enable_if&lt;              is_residual_functor_op&lt;ResidualViewFunctor&gt;::value &amp;&amp;              (is_ad_functor_op&lt;ResidualViewFunctor&gt;::value ||               is_sd_functor_op&lt;ResidualViewFunctor&gt;::value)&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeakForms_1_1SelfLinearization_1_1ResidualView.html">SelfLinearization::ResidualView</a>&lt;<a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a>&gt; WeakForms::residual_form </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a> &amp;&#160;</td>
          <td class="paramname"><em>functor_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function that generates a self-linearizing residual form from a residual view functor.</p>
<p>For more information about the self-linearizing form that is created, please refer to the documentation of the <a class="el" href="classWeakForms_1_1SelfLinearization_1_1ResidualView.html">SelfLinearization::ResidualView</a> class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a></td><td>A class that is recognised to be a residual view functor operation, as well as a functor that is either AD compatible SD compatible (i.e. can exploit either automatic or symbolic differentiation). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor_op</td><td>An residual functor that is to be converted to a form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SelfLinearization::ResidualView&lt;ResidualViewFunctor&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="self__linearizing__forms_8h_source.html#l01558">1558</a> of file <a class="el" href="self__linearizing__forms_8h_source.html">self_linearizing_forms.h</a>.</p>

</div>
</div>
<a id="a892dd380ef93823647570cdfb03d98db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892dd380ef93823647570cdfb03d98db">&#9670;&nbsp;</a></span>integrate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Integrand , typename IntegralType , typename  = typename std::enable_if&lt;is_valid_integration_domain&lt;              typename std::decay&lt;IntegralType&gt;::type&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WeakForms::integrate </td>
          <td>(</td>
          <td class="paramtype">const Integrand &amp;&#160;</td>
          <td class="paramname"><em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntegralType &amp;&#160;</td>
          <td class="paramname"><em>integral</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function that returns an operator that represents an integral operation. </p>
<p>This function is not typically called directly by a user, but rather would be used by a form or function integrator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">integrand</td><td>The quantity or set of operations that are to be integrated. </td></tr>
    <tr><td class="paramname">integral</td><td>The domain over which the <code>integrand</code> is to be integrated. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="symbolic__integral_8h_source.html#l00386">386</a> of file <a class="el" href="symbolic__integral_8h_source.html">symbolic_integral.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceWeakForms_1_1Operators_html_aec4fa4a0321d7d1b75b1dd94ae07a48bae2b6dfb8a5c48206992d8310d176c37c"><div class="ttname"><a href="namespaceWeakForms_1_1Operators.html#aec4fa4a0321d7d1b75b1dd94ae07a48bae2b6dfb8a5c48206992d8310d176c37c">WeakForms::Operators::SymbolicOpCodes::gradient</a></div><div class="ttdeci">@ gradient</div></div>
<div class="ttc" id="anamespaceWeakForms_1_1Operators_html_aec4fa4a0321d7d1b75b1dd94ae07a48ba2063c1608d6e0baf80249c42e2be5804"><div class="ttname"><a href="namespaceWeakForms_1_1Operators.html#aec4fa4a0321d7d1b75b1dd94ae07a48ba2063c1608d6e0baf80249c42e2be5804">WeakForms::Operators::SymbolicOpCodes::value</a></div><div class="ttdeci">@ value</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
