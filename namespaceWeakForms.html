<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Weak forms for deal.II: WeakForms Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Weak forms for deal.II
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">WeakForms Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceWeakForms_1_1Decorations"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1Decorations.html">Decorations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1NonLinear"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1NonLinear.html">NonLinear</a></td></tr>
<tr class="memdesc:namespaceWeakForms_1_1NonLinear"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace that encapsulates aliases that are relevant for non-linear problems. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1numbers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1numbers.html">numbers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1Operators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1Operators.html">Operators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1SelfLinearization"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1SelfLinearization.html">SelfLinearization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1SubSpaceExtractors"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1SubSpaceExtractors.html">SubSpaceExtractors</a></td></tr>
<tr class="memdesc:namespaceWeakForms_1_1SubSpaceExtractors"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace dedicated to objects that help to identify subspaces within a global finite element space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1SubSpaceViews"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1SubSpaceViews.html">SubSpaceViews</a></td></tr>
<tr class="memdesc:namespaceWeakForms_1_1SubSpaceViews"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace dedicated to objects that represent a subspace within a global finite element space. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1types"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1types.html">types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceWeakForms_1_1Utilities"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms_1_1Utilities.html">Utilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1AD__SD__Functor__Cache.html">AD_SD_Functor_Cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent data for AD and SD calculations.  <a href="classWeakForms_1_1AD__SD__Functor__Cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1are__scalar__types.html">are_scalar_types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see two classes are both scalar types.  <a href="structWeakForms_1_1are__scalar__types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1AssemblerBase.html">AssemblerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for assemblers of the discrete integral forms.  <a href="classWeakForms_1_1AssemblerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1BilinearForm.html">BilinearForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents any linear form.  <a href="classWeakForms_1_1BilinearForm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1BoundaryIntegral.html">BoundaryIntegral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that encapsulates the subset of elements that are to be considered as part of a boundary integral.  <a href="classWeakForms_1_1BoundaryIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents the point-wise decomposition of an energy functional.  <a href="classWeakForms_1_1EnergyFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1FieldSolution.html">FieldSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents a (discrete) global finite element field solution.  <a href="classWeakForms_1_1FieldSolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1FunctionIntegrator.html">FunctionIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integrator for user-defined functions.  <a href="classWeakForms_1_1FunctionIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1Functor.html">Functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for other objects that represent functors.  <a href="classWeakForms_1_1Functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1Integral.html">Integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for other objects that represent (sub)domains of integration.  <a href="classWeakForms_1_1Integral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1Integrator.html">Integrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integrator for functors.  <a href="classWeakForms_1_1Integrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1InterfaceIntegral.html">InterfaceIntegral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that encapsulates the subset of elements that are to be considered as part of an interface integral.  <a href="classWeakForms_1_1InterfaceIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__ad__functor__op.html">is_ad_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that is automatically differentiable.  <a href="structWeakForms_1_1is__ad__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__bilinear__form.html">is_bilinear_form</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a binary form.  <a href="structWeakForms_1_1is__bilinear__form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__binary__integral__op.html">is_binary_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a binary operator that has been integrated.  <a href="structWeakForms_1_1is__binary__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__binary__op.html">is_binary_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a binary operator.  <a href="structWeakForms_1_1is__binary__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__boundary__integral__op.html">is_boundary_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a boundary integral (domain).  <a href="structWeakForms_1_1is__boundary__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__boundary__op.html">is_boundary_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that can be evaluated on a boundary.  <a href="structWeakForms_1_1is__boundary__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__cache__functor__op.html">is_cache_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an elementary operation involving a cached functor.  <a href="structWeakForms_1_1is__cache__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__cell__geometry__op.html">is_cell_geometry_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that involves a geometry operation of a discrete finite element (cell).  <a href="structWeakForms_1_1is__cell__geometry__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__compatible__with__scalar__arithmetic.html">is_compatible_with_scalar_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that can be sensibly used in conjunction with a scalar arithmetic operation.  <a href="structWeakForms_1_1is__compatible__with__scalar__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__energy__functor__op.html">is_energy_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator represents an energy functor.  <a href="structWeakForms_1_1is__energy__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__evaluated__with__scratch__data.html">is_evaluated_with_scratch_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that must be evaluated using deal.II's MeshWorker::ScratchData class.  <a href="structWeakForms_1_1is__evaluated__with__scratch__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__field__solution.html">is_field_solution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an operation involving the field solution (or a component thereof).  <a href="structWeakForms_1_1is__field__solution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__field__solution__op.html">is_field_solution_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is an elementary or composite (unary or binary) symbolic operator that involves the field solution (or a view into it).  <a href="structWeakForms_1_1is__field__solution__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__functor__op.html">is_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an elementary operation involving a functor.  <a href="structWeakForms_1_1is__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__integral__op.html">is_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents any operator that has been integrated.  <a href="structWeakForms_1_1is__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__interface__integral__op.html">is_interface_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an interface integral (domain).  <a href="structWeakForms_1_1is__interface__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__interface__op.html">is_interface_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that can be evaluated on an interface.  <a href="structWeakForms_1_1is__interface__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__linear__form.html">is_linear_form</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a linear form.  <a href="structWeakForms_1_1is__linear__form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__residual__functor__op.html">is_residual_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator represents a residual functor.  <a href="structWeakForms_1_1is__residual__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1is__scalar__type.html">is_scalar_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a scalar type.  <a href="classWeakForms_1_1is__scalar__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__sd__functor__op.html">is_sd_functor_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that is symbolically differentiable.  <a href="structWeakForms_1_1is__sd__functor__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__self__linearizing__form.html">is_self_linearizing_form</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a form that has the ability to linearise itself.  <a href="structWeakForms_1_1is__self__linearizing__form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__subspace__view.html">is_subspace_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a view into the global test function, trial solution, or field solution.  <a href="structWeakForms_1_1is__subspace__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__symbolic__integral__op.html">is_symbolic_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents another elementary operator that has been integrated.  <a href="structWeakForms_1_1is__symbolic__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__test__function.html">is_test_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an operation involving the test function (or a component thereof).  <a href="structWeakForms_1_1is__test__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__test__function__op.html">is_test_function_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is an elementary or composite (unary or binary) symbolic operator that involves the test function (or a view into it).  <a href="structWeakForms_1_1is__test__function__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__trial__solution.html">is_trial_solution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents an operation involving the trial solution (or a component thereof).  <a href="structWeakForms_1_1is__trial__solution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__trial__solution__op.html">is_trial_solution_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is an elementary or composite (unary or binary) symbolic operator that involves the trial solution (or a view into it).  <a href="structWeakForms_1_1is__trial__solution__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__unary__integral__op.html">is_unary_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a unary operator that has been integrated.  <a href="structWeakForms_1_1is__unary__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__unary__op.html">is_unary_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a unary operator.  <a href="structWeakForms_1_1is__unary__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__valid__form__functor.html">is_valid_form_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a valid elementary of composite (unary or binary) symbolic operator that can be passed into, and evaluated within, a linear or binary form.  <a href="structWeakForms_1_1is__valid__form__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__valid__integration__domain.html">is_valid_integration_domain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a domain of integration.  <a href="structWeakForms_1_1is__valid__integration__domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1is__volume__integral__op.html">is_volume_integral_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait that checks to see if a class is a symbolic operator that represents a volume integral (domain).  <a href="structWeakForms_1_1is__volume__integral__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1LinearForm.html">LinearForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents any linear form.  <a href="classWeakForms_1_1LinearForm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1MatrixBasedAssembler.html">MatrixBasedAssembler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix-based assembler of the discrete integral forms.  <a href="classWeakForms_1_1MatrixBasedAssembler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1Normal.html">Normal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that represents the normal of the cell, as evaluated at a boundary or an interface.  <a href="classWeakForms_1_1Normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1ResidualFunctor.html">ResidualFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents the point-wise decomposition of the residual, or a component of the residual.  <a href="classWeakForms_1_1ResidualFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents the point-wise decomposition of a component of the residual.  <a href="classWeakForms_1_1ResidualViewFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1ScalarCacheFunctor.html">ScalarCacheFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns (field-dependent) scalar values upon evaluation.  <a href="classWeakForms_1_1ScalarCacheFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1ScalarFunctionFunctor.html">ScalarFunctionFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that acts as a wrapper for a scalar deal.II function.  <a href="classWeakForms_1_1ScalarFunctionFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1ScalarFunctor.html">ScalarFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns scalar values upon evaluation.  <a href="classWeakForms_1_1ScalarFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1SolutionExtractionData.html">SolutionExtractionData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that facilitates the extraction of data from the field solution.  <a href="structWeakForms_1_1SolutionExtractionData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1SolutionStorage.html">SolutionStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An class that allows one to store solution vectors that may be referenced by the weak forms during assembly.  <a href="classWeakForms_1_1SolutionStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1Space.html">Space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for objects that encapsulate the notion of a (discrete) global finite element space.  <a href="classWeakForms_1_1Space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1SymbolicDecorations.html">SymbolicDecorations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class whose purpose is to construct all decorations for symbols required for ASCII and LaTeX output.  <a href="structWeakForms_1_1SymbolicDecorations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1SymbolicNames.html">SymbolicNames</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure that defines the labels to be used to construct symbolic variables identifiers.  <a href="structWeakForms_1_1SymbolicNames.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1SymbolicNamesAscii.html">SymbolicNamesAscii</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure that defines the labels to be used to construct ASCII-formatted symbolic variables identifiers.  <a href="structWeakForms_1_1SymbolicNamesAscii.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWeakForms_1_1SymbolicNamesLaTeX.html">SymbolicNamesLaTeX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure that defines the labels to be used to construct LaTeX-formatted symbolic variables identifiers.  <a href="structWeakForms_1_1SymbolicNamesLaTeX.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1SymmetricTensorCacheFunctor.html">SymmetricTensorCacheFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns (field-dependent) symmetric tensor values upon evaluation.  <a href="classWeakForms_1_1SymmetricTensorCacheFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1SymmetricTensorFunctor.html">SymmetricTensorFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns a symmetric tensor upon evaluation.  <a href="classWeakForms_1_1SymmetricTensorFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1TensorCacheFunctor.html">TensorCacheFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns (field-dependent) tensor values upon evaluation.  <a href="classWeakForms_1_1TensorCacheFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1TensorFunctionFunctor.html">TensorFunctionFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that acts as a wrapper for a tensor-valued deal.II function.  <a href="classWeakForms_1_1TensorFunctionFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1TensorFunctor.html">TensorFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that returns a tensor upon evaluation.  <a href="classWeakForms_1_1TensorFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1TestFunction.html">TestFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents a (discrete) global finite element test function.  <a href="classWeakForms_1_1TestFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1TrialSolution.html">TrialSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents a (discrete) global finite element trial solution.  <a href="classWeakForms_1_1TrialSolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeakForms_1_1VolumeIntegral.html">VolumeIntegral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that encapsulates the subset of elements that are to be considered as part of a volume integral.  <a href="classWeakForms_1_1VolumeIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0a9c531383d9c68277a50599e3e9f565"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga0a9c531383d9c68277a50599e3e9f565"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functors.html#ga0a9c531383d9c68277a50599e3e9f565">VectorCacheFunctor</a> = <a class="el" href="classWeakForms_1_1TensorCacheFunctor.html">TensorCacheFunctor</a>&lt; 1, dim &gt;</td></tr>
<tr class="separator:ga0a9c531383d9c68277a50599e3e9f565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69e444116cbcbd5ccf773acddc015de6"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga69e444116cbcbd5ccf773acddc015de6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functors.html#ga69e444116cbcbd5ccf773acddc015de6">VectorFunctor</a> = <a class="el" href="classWeakForms_1_1TensorFunctor.html">TensorFunctor</a>&lt; 1, dim &gt;</td></tr>
<tr class="separator:ga69e444116cbcbd5ccf773acddc015de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a4e449c6edab12a90df92459fae2d6"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga76a4e449c6edab12a90df92459fae2d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functors.html#ga76a4e449c6edab12a90df92459fae2d6">VectorFunctionFunctor</a> = <a class="el" href="classWeakForms_1_1TensorFunctionFunctor.html">TensorFunctionFunctor</a>&lt; 1, dim &gt;</td></tr>
<tr class="separator:ga76a4e449c6edab12a90df92459fae2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acaa0a4172ad5893b342da4aae68fb3a4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> { <br />
&#160;&#160;<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a34c4dedca0d31e298e5fb97dd7f47a96">form_components_default</a> = 0, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a54ecd6b612d5386ff36b545c081c2c1d">multiplicity_I</a> = 0x0001, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a52eda1df3a1fe00eb1fbc8d4693c8f7d">multiplicity_J</a> = 0x0002, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a8a40a6051a8a98cff6d5395cef34e94e">dof_I_component_i</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4acc3c6969be48c9763f101891745480e6">dof_I_component_j</a> = 0x0008, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a8d56c5d28292ad64b0978eda61d01e73">dof_J_component_i</a> = 0x0010, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4ab22689254b0cc55000ab2509c90efcce">dof_J_component_j</a> = 0x0020, 
<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4a286506621645e37af87ab00331615d9b">local_shape_function_kronecker_delta</a> = 0x0040
<br />
 }</td></tr>
<tr class="separator:acaa0a4172ad5893b342da4aae68fb3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a36e97adeeaa7ab0ed216e0587a70080c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a36e97adeeaa7ab0ed216e0587a70080c">operator|</a> (const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f1, const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f2)</td></tr>
<tr class="separator:a36e97adeeaa7ab0ed216e0587a70080c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320830063be57b317a00c519cb979e04"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a320830063be57b317a00c519cb979e04">operator|=</a> (<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;f1, const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f2)</td></tr>
<tr class="separator:a320830063be57b317a00c519cb979e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d14de582aceac693625e252b461da59"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a7d14de582aceac693625e252b461da59">operator&amp;</a> (const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f1, const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f2)</td></tr>
<tr class="separator:a7d14de582aceac693625e252b461da59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1086e3a3e67706edcefd70e630050b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWeakForms.html#a0d1086e3a3e67706edcefd70e630050b">operator&amp;=</a> (<a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;f1, const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> f2)</td></tr>
<tr class="separator:a0d1086e3a3e67706edcefd70e630050b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd7b5677e0e315c3c177d2dbe7cb7f7"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename Functor , typename TrialSpaceOp , typename  = typename std::enable_if&lt;is_valid_form_functor&lt;Functor&gt;::value &amp;&amp;                                       !is_scalar_type&lt;Functor&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gafdd7b5677e0e315c3c177d2dbe7cb7f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1BilinearForm.html">BilinearForm</a>&lt; TestSpaceOp, <a class="el" href="classWeakForms_1_1Functor.html">Functor</a>, TrialSpaceOp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#gafdd7b5677e0e315c3c177d2dbe7cb7f7">bilinear_form</a> (const TestSpaceOp &amp;test_space_op, const <a class="el" href="classWeakForms_1_1Functor.html">Functor</a> &amp;functor_op, const TrialSpaceOp &amp;trial_space_op)</td></tr>
<tr class="memdesc:gafdd7b5677e0e315c3c177d2dbe7cb7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that is used to create bilinear forms.  <a href="group__convenience__functions.html#gafdd7b5677e0e315c3c177d2dbe7cb7f7">More...</a><br /></td></tr>
<tr class="separator:gafdd7b5677e0e315c3c177d2dbe7cb7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30312909935a89c48022b69c1f309de"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename ScalarType , typename TrialSpaceOp , typename  = typename std::enable_if&lt;              !is_valid_form_functor&lt;ScalarType&gt;::value &amp;&amp;              is_scalar_type&lt;ScalarType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gaf30312909935a89c48022b69c1f309de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#gaf30312909935a89c48022b69c1f309de">bilinear_form</a> (const TestSpaceOp &amp;test_space_op, const ScalarType &amp;value, const TrialSpaceOp &amp;trial_space_op)</td></tr>
<tr class="memdesc:gaf30312909935a89c48022b69c1f309de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that is used to create bilinear forms.  <a href="group__convenience__functions.html#gaf30312909935a89c48022b69c1f309de">More...</a><br /></td></tr>
<tr class="separator:gaf30312909935a89c48022b69c1f309de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78136c6b281da64a8fa2a485261bfbec"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename TrialSpaceOp , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </td></tr>
<tr class="memitem:ga78136c6b281da64a8fa2a485261bfbec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga78136c6b281da64a8fa2a485261bfbec">bilinear_form</a> (const TestSpaceOp &amp;test_space_op, const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;value, const TrialSpaceOp &amp;trial_space_op)</td></tr>
<tr class="memdesc:ga78136c6b281da64a8fa2a485261bfbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that is used to create bilinear forms.  <a href="group__convenience__functions.html#ga78136c6b281da64a8fa2a485261bfbec">More...</a><br /></td></tr>
<tr class="separator:ga78136c6b281da64a8fa2a485261bfbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa87ca80088ec1a1bcacf0a0e9bd7cce"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename TrialSpaceOp , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </td></tr>
<tr class="memitem:gaaa87ca80088ec1a1bcacf0a0e9bd7cce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#gaaa87ca80088ec1a1bcacf0a0e9bd7cce">bilinear_form</a> (const TestSpaceOp &amp;test_space_op, const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;value, const TrialSpaceOp &amp;trial_space_op)</td></tr>
<tr class="memdesc:gaaa87ca80088ec1a1bcacf0a0e9bd7cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that is used to create bilinear forms.  <a href="group__convenience__functions.html#gaaa87ca80088ec1a1bcacf0a0e9bd7cce">More...</a><br /></td></tr>
<tr class="separator:gaaa87ca80088ec1a1bcacf0a0e9bd7cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1def7786361fdb4f678d2aefda297d83"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename TrialSpaceOp &gt; </td></tr>
<tr class="memitem:ga1def7786361fdb4f678d2aefda297d83"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga1def7786361fdb4f678d2aefda297d83">bilinear_form</a> (const TestSpaceOp &amp;test_space_op, const TrialSpaceOp &amp;trial_space_op)</td></tr>
<tr class="memdesc:ga1def7786361fdb4f678d2aefda297d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that is used to create bilinear forms.  <a href="group__convenience__functions.html#ga1def7786361fdb4f678d2aefda297d83">More...</a><br /></td></tr>
<tr class="separator:ga1def7786361fdb4f678d2aefda297d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7972c9f91c2f78a33eb88106b5eab156"><td class="memTemplParams" colspan="2">template&lt;typename... SymbolicOpsSubSpaceFieldSolution&gt; </td></tr>
<tr class="memitem:ga7972c9f91c2f78a33eb88106b5eab156"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a>&lt; SymbolicOpsSubSpaceFieldSolution... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga7972c9f91c2f78a33eb88106b5eab156">energy_functor</a> (const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex, const SymbolicOpsSubSpaceFieldSolution &amp;...symbolic_op_field_solutions)</td></tr>
<tr class="memdesc:ga7972c9f91c2f78a33eb88106b5eab156"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for creating an <a class="el" href="classWeakForms_1_1EnergyFunctor.html" title="A class that represents the point-wise decomposition of an energy functional.">EnergyFunctor</a>.  <a href="group__convenience__functions.html#ga7972c9f91c2f78a33eb88106b5eab156">More...</a><br /></td></tr>
<tr class="separator:ga7972c9f91c2f78a33eb88106b5eab156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aab0434f0dc6abdc1b1032a976fe272"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga4aab0434f0dc6abdc1b1032a976fe272"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga4aab0434f0dc6abdc1b1032a976fe272">constant_scalar</a> (const ScalarType &amp;value, const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex)</td></tr>
<tr class="memdesc:ga4aab0434f0dc6abdc1b1032a976fe272"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant scalar value upon evaluation.  <a href="group__convenience__functions.html#ga4aab0434f0dc6abdc1b1032a976fe272">More...</a><br /></td></tr>
<tr class="separator:ga4aab0434f0dc6abdc1b1032a976fe272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga438768963165239d8cb2156f787497a4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga438768963165239d8cb2156f787497a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga438768963165239d8cb2156f787497a4">constant_scalar</a> (const ScalarType &amp;value)</td></tr>
<tr class="memdesc:ga438768963165239d8cb2156f787497a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant scalar value upon evaluation.  <a href="group__convenience__functions.html#ga438768963165239d8cb2156f787497a4">More...</a><br /></td></tr>
<tr class="separator:ga438768963165239d8cb2156f787497a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b985f4612cada863c97eff5804f427f"><td class="memTemplParams" colspan="2">template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga9b985f4612cada863c97eff5804f427f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga9b985f4612cada863c97eff5804f427f">constant_tensor</a> (const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;value, const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex)</td></tr>
<tr class="memdesc:ga9b985f4612cada863c97eff5804f427f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant tensor value upon evaluation.  <a href="group__convenience__functions.html#ga9b985f4612cada863c97eff5804f427f">More...</a><br /></td></tr>
<tr class="separator:ga9b985f4612cada863c97eff5804f427f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b0881a8be1b214a167b49a4086b8d12"><td class="memTemplParams" colspan="2">template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga0b0881a8be1b214a167b49a4086b8d12"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga0b0881a8be1b214a167b49a4086b8d12">constant_tensor</a> (const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;value)</td></tr>
<tr class="memdesc:ga0b0881a8be1b214a167b49a4086b8d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant tensor value upon evaluation.  <a href="group__convenience__functions.html#ga0b0881a8be1b214a167b49a4086b8d12">More...</a><br /></td></tr>
<tr class="separator:ga0b0881a8be1b214a167b49a4086b8d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b919bc91e1d9204c2c25b5e46abd64"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga62b919bc91e1d9204c2c25b5e46abd64"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga62b919bc91e1d9204c2c25b5e46abd64">constant_vector</a> (const Tensor&lt; 1, spacedim, ScalarType &gt; &amp;value, const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex)</td></tr>
<tr class="memdesc:ga62b919bc91e1d9204c2c25b5e46abd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant vector (rank-1 tensor) value upon evaluation.  <a href="group__convenience__functions.html#ga62b919bc91e1d9204c2c25b5e46abd64">More...</a><br /></td></tr>
<tr class="separator:ga62b919bc91e1d9204c2c25b5e46abd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc1a23ded2d0b676dbc7f0771a62603"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga3cc1a23ded2d0b676dbc7f0771a62603"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga3cc1a23ded2d0b676dbc7f0771a62603">constant_vector</a> (const Tensor&lt; 1, spacedim, ScalarType &gt; &amp;value)</td></tr>
<tr class="memdesc:ga3cc1a23ded2d0b676dbc7f0771a62603"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant vector (rank-1 tensor) value upon evaluation.  <a href="group__convenience__functions.html#ga3cc1a23ded2d0b676dbc7f0771a62603">More...</a><br /></td></tr>
<tr class="separator:ga3cc1a23ded2d0b676dbc7f0771a62603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c9fa89a4ce12793236437a8b314dfb"><td class="memTemplParams" colspan="2">template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:gac8c9fa89a4ce12793236437a8b314dfb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#gac8c9fa89a4ce12793236437a8b314dfb">constant_symmetric_tensor</a> (const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;value, const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex)</td></tr>
<tr class="memdesc:gac8c9fa89a4ce12793236437a8b314dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant symmetric tensor value upon evaluation.  <a href="group__convenience__functions.html#gac8c9fa89a4ce12793236437a8b314dfb">More...</a><br /></td></tr>
<tr class="separator:gac8c9fa89a4ce12793236437a8b314dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5de8c9d6bf9ce8ab1f30f169202855e9"><td class="memTemplParams" colspan="2">template&lt;int dim, int rank, int spacedim, typename ScalarType &gt; </td></tr>
<tr class="memitem:ga5de8c9d6bf9ce8ab1f30f169202855e9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga5de8c9d6bf9ce8ab1f30f169202855e9">constant_symmetric_tensor</a> (const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;value)</td></tr>
<tr class="memdesc:ga5de8c9d6bf9ce8ab1f30f169202855e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that always returns the same constant symmetric tensor value upon evaluation.  <a href="group__convenience__functions.html#ga5de8c9d6bf9ce8ab1f30f169202855e9">More...</a><br /></td></tr>
<tr class="separator:ga5de8c9d6bf9ce8ab1f30f169202855e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7da85d217255f157eddcd2a40ee570"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename Functor , typename  = typename std::enable_if&lt;is_valid_form_functor&lt;Functor&gt;::value &amp;&amp;                                       !is_scalar_type&lt;Functor&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga7b7da85d217255f157eddcd2a40ee570"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1LinearForm.html">LinearForm</a>&lt; TestSpaceOp, <a class="el" href="classWeakForms_1_1Functor.html">Functor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga7b7da85d217255f157eddcd2a40ee570">linear_form</a> (const TestSpaceOp &amp;test_space_op, const <a class="el" href="classWeakForms_1_1Functor.html">Functor</a> &amp;functor_op)</td></tr>
<tr class="memdesc:ga7b7da85d217255f157eddcd2a40ee570"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that is used to create linear forms.  <a href="group__convenience__functions.html#ga7b7da85d217255f157eddcd2a40ee570">More...</a><br /></td></tr>
<tr class="separator:ga7b7da85d217255f157eddcd2a40ee570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee40ff51bb5da73a4e19819b40adf9a"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename ScalarType , typename  = typename std::enable_if&lt;              !is_valid_form_functor&lt;ScalarType&gt;::value &amp;&amp;              is_scalar_type&lt;ScalarType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gafee40ff51bb5da73a4e19819b40adf9a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#gafee40ff51bb5da73a4e19819b40adf9a">linear_form</a> (const TestSpaceOp &amp;test_space_op, const ScalarType &amp;value)</td></tr>
<tr class="memdesc:gafee40ff51bb5da73a4e19819b40adf9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that is used to create linear forms.  <a href="group__convenience__functions.html#gafee40ff51bb5da73a4e19819b40adf9a">More...</a><br /></td></tr>
<tr class="separator:gafee40ff51bb5da73a4e19819b40adf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b18995abdd2d8eb0f1d82793433d515"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </td></tr>
<tr class="memitem:ga2b18995abdd2d8eb0f1d82793433d515"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga2b18995abdd2d8eb0f1d82793433d515">linear_form</a> (const TestSpaceOp &amp;test_space_op, const Tensor&lt; rank, spacedim, ScalarType &gt; &amp;value)</td></tr>
<tr class="memdesc:ga2b18995abdd2d8eb0f1d82793433d515"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that is used to create linear forms.  <a href="group__convenience__functions.html#ga2b18995abdd2d8eb0f1d82793433d515">More...</a><br /></td></tr>
<tr class="separator:ga2b18995abdd2d8eb0f1d82793433d515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4497dc77582f8f26dcd908b333a8aae0"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , int rank, int spacedim, typename ScalarType , typename  = typename is_scalar_type&lt;ScalarType&gt;::type&gt; </td></tr>
<tr class="memitem:ga4497dc77582f8f26dcd908b333a8aae0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga4497dc77582f8f26dcd908b333a8aae0">linear_form</a> (const TestSpaceOp &amp;test_space_op, const SymmetricTensor&lt; rank, spacedim, ScalarType &gt; &amp;value)</td></tr>
<tr class="memdesc:ga4497dc77582f8f26dcd908b333a8aae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that is used to create linear forms.  <a href="group__convenience__functions.html#ga4497dc77582f8f26dcd908b333a8aae0">More...</a><br /></td></tr>
<tr class="separator:ga4497dc77582f8f26dcd908b333a8aae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b1f385584348c61cedf4a1092de1fc"><td class="memTemplParams" colspan="2">template&lt;typename... SymbolicOpsSubSpaceFieldSolution&gt; </td></tr>
<tr class="memitem:gad1b1f385584348c61cedf4a1092de1fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1ResidualFunctor.html">ResidualFunctor</a>&lt; SymbolicOpsSubSpaceFieldSolution... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#gad1b1f385584348c61cedf4a1092de1fc">residual_functor</a> (const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex, const SymbolicOpsSubSpaceFieldSolution &amp;...symbolic_op_field_solutions)</td></tr>
<tr class="memdesc:gad1b1f385584348c61cedf4a1092de1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for creating a <a class="el" href="classWeakForms_1_1ResidualFunctor.html" title="A class that represents the point-wise decomposition of the residual, or a component of the residual.">ResidualFunctor</a>.  <a href="group__convenience__functions.html#gad1b1f385584348c61cedf4a1092de1fc">More...</a><br /></td></tr>
<tr class="separator:gad1b1f385584348c61cedf4a1092de1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1d11b9bc21b0f17dac3f1b2595e135b"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename... SymbolicOpsSubSpaceFieldSolution&gt; </td></tr>
<tr class="memitem:gaf1d11b9bc21b0f17dac3f1b2595e135b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a>&lt; SymbolicOpsSubSpaceFieldSolution... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#gaf1d11b9bc21b0f17dac3f1b2595e135b">residual_view_functor</a> (const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex, const TestSpaceOp &amp;test_space_op, const SymbolicOpsSubSpaceFieldSolution &amp;...symbolic_op_field_solutions)</td></tr>
<tr class="memdesc:gaf1d11b9bc21b0f17dac3f1b2595e135b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for creating a <a class="el" href="classWeakForms_1_1ResidualViewFunctor.html" title="A class that represents the point-wise decomposition of a component of the residual.">ResidualViewFunctor</a>.  <a href="group__convenience__functions.html#gaf1d11b9bc21b0f17dac3f1b2595e135b">More...</a><br /></td></tr>
<tr class="separator:gaf1d11b9bc21b0f17dac3f1b2595e135b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2494242b5c1af1c342c90047385bb2f5"><td class="memTemplParams" colspan="2">template&lt;typename EnergyFunctor , typename  = typename std::enable_if&lt;              is_energy_functor_op&lt;EnergyFunctor&gt;::value &amp;&amp;              (is_ad_functor_op&lt;EnergyFunctor&gt;::value ||               is_sd_functor_op&lt;EnergyFunctor&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:ga2494242b5c1af1c342c90047385bb2f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1SelfLinearization_1_1EnergyFunctionalForm.html">SelfLinearization::EnergyFunctionalForm</a>&lt; <a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga2494242b5c1af1c342c90047385bb2f5">energy_functional_form</a> (const <a class="el" href="classWeakForms_1_1EnergyFunctor.html">EnergyFunctor</a> &amp;functor_op)</td></tr>
<tr class="memdesc:ga2494242b5c1af1c342c90047385bb2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that generates a self-linearizing energy functional form from an energy functor.  <a href="group__convenience__functions.html#ga2494242b5c1af1c342c90047385bb2f5">More...</a><br /></td></tr>
<tr class="separator:ga2494242b5c1af1c342c90047385bb2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5b46db70926d1eb681770d8fad1cbcb"><td class="memTemplParams" colspan="2">template&lt;typename ResidualViewFunctor , typename  = typename std::enable_if&lt;              is_residual_functor_op&lt;ResidualViewFunctor&gt;::value &amp;&amp;              (is_ad_functor_op&lt;ResidualViewFunctor&gt;::value ||               is_sd_functor_op&lt;ResidualViewFunctor&gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:gaf5b46db70926d1eb681770d8fad1cbcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWeakForms_1_1SelfLinearization_1_1ResidualViewForm.html">SelfLinearization::ResidualViewForm</a>&lt; <a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#gaf5b46db70926d1eb681770d8fad1cbcb">residual_form</a> (const <a class="el" href="classWeakForms_1_1ResidualViewFunctor.html">ResidualViewFunctor</a> &amp;functor_op)</td></tr>
<tr class="memdesc:gaf5b46db70926d1eb681770d8fad1cbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that generates a self-linearizing residual form from a residual view functor.  <a href="group__convenience__functions.html#gaf5b46db70926d1eb681770d8fad1cbcb">More...</a><br /></td></tr>
<tr class="separator:gaf5b46db70926d1eb681770d8fad1cbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga657cb46699fa5d176e4246bb74525ae9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim, typename CompositeSymbolicOp &gt; </td></tr>
<tr class="memitem:ga657cb46699fa5d176e4246bb74525ae9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga657cb46699fa5d176e4246bb74525ae9">energy_functional_form</a> (const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex, const CompositeSymbolicOp &amp;functor_op, const enum dealii::Differentiation::SD::OptimizerType optimization_method=dealii::Differentiation::SD::OptimizerType::llvm, const enum dealii::Differentiation::SD::OptimizationFlags optimization_flags=dealii::Differentiation::SD::OptimizationFlags::optimize_default)</td></tr>
<tr class="memdesc:ga657cb46699fa5d176e4246bb74525ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that generates a self-linearizing energy functional form from a (composite) symbolic operation.  <a href="group__convenience__functions.html#ga657cb46699fa5d176e4246bb74525ae9">More...</a><br /></td></tr>
<tr class="separator:ga657cb46699fa5d176e4246bb74525ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga736011eb95e82e8b27d2e272f7438e85"><td class="memTemplParams" colspan="2">template&lt;typename TestSpaceOp , typename CompositeSymbolicOp &gt; </td></tr>
<tr class="memitem:ga736011eb95e82e8b27d2e272f7438e85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga736011eb95e82e8b27d2e272f7438e85">residual_view_form</a> (const std::string &amp;symbol_ascii, const std::string &amp;symbol_latex, const TestSpaceOp &amp;test_space_op, const CompositeSymbolicOp &amp;functor_op, const enum dealii::Differentiation::SD::OptimizerType optimization_method=dealii::Differentiation::SD::OptimizerType::llvm, const enum dealii::Differentiation::SD::OptimizationFlags optimization_flags=dealii::Differentiation::SD::OptimizationFlags::optimize_default)</td></tr>
<tr class="memdesc:ga736011eb95e82e8b27d2e272f7438e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that generates a self-linearizing residual view functional form from a (composite) symbolic operation.  <a href="group__convenience__functions.html#ga736011eb95e82e8b27d2e272f7438e85">More...</a><br /></td></tr>
<tr class="separator:ga736011eb95e82e8b27d2e272f7438e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga892dd380ef93823647570cdfb03d98db"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType  = double, typename Integrand , typename IntegralType , typename  = typename std::enable_if&lt;is_valid_integration_domain&lt;              typename std::decay&lt;IntegralType&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga892dd380ef93823647570cdfb03d98db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convenience__functions.html#ga892dd380ef93823647570cdfb03d98db">integrate</a> (const Integrand &amp;integrand, const IntegralType &amp;integral)</td></tr>
<tr class="memdesc:ga892dd380ef93823647570cdfb03d98db"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that returns an operator that represents an integral operation.  <a href="group__convenience__functions.html#ga892dd380ef93823647570cdfb03d98db">More...</a><br /></td></tr>
<tr class="separator:ga892dd380ef93823647570cdfb03d98db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acaa0a4172ad5893b342da4aae68fb3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa0a4172ad5893b342da4aae68fb3a4">&#9670;&nbsp;</a></span>BilinearFormComponentFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">WeakForms::BilinearFormComponentFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A set of filters that are applied during the assembly process for bilinear forms.</p>
<p>These filters are used to skip some assembly contributions, or to extract certain components of vectorial or tensorial shape functions. To understand what these filters are to do, it is helpful to first define some notation:</p><ul>
<li><code>I</code> and <code>J</code> refer to the local degree of freedom indices respectively associated with the test and trial shape functions.</li>
<li><code>component_i</code> and <code>component_j</code> are, respectively, the index of the <code>I</code>th and <code>J</code>th shape functions within the finite element (system). The component of the <code>K</code>th shape function would correspond to <code>finite_element.system_to_component_index(K).first;</code></li>
<li><code>multiplicity_I</code> and <code>multiplicity_J</code> are, respectively, the copy of the base finite element within the finite element (system) that corresponds with the <code>I</code>th and <code>J</code>th degree of freedom. The multiplicity of the <code>K</code>th shape function is the equivalent to what is returned by <code>finite_element.system_to_base_index(K).first.second;</code>.</li>
</ul>
<p>Also refer to the introduction of the deal.II <a href="https://dealii.org/developer/doxygen/deal.II/classFiniteElement.html">FiniteElement</a> class for further insights. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a34c4dedca0d31e298e5fb97dd7f47a96"></a>form_components_default&#160;</td><td class="fielddoc"><p>Apply no filters.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this filter alone results in optimum performance code being executed by the assembler. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a54ecd6b612d5386ff36b545c081c2c1d"></a>multiplicity_I&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. fully evaluated shape function operator), extract its "multiplicity index" component that is associated with the <code>I</code>th local shape function.</p>
<dl class="section note"><dt>Note</dt><dd>This extraction operation always occurs in preference to others. So if it is combined with other filters acting on index <code>I</code>, then the extraction of this component of the (tensorial) shape function operation result will happen first. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a52eda1df3a1fe00eb1fbc8d4693c8f7d"></a>multiplicity_J&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. fully evaluated shape function operator), extract its "multiplicity index" component that is associated with the <code>J</code>th local shape function.</p>
<dl class="section note"><dt>Note</dt><dd>This extraction operation always occurs in preference to others. So if it is combined with other filters acting on index <code>J</code>, then the extraction of this component of the (tensorial) shape function operation result will happen first. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a8a40a6051a8a98cff6d5395cef34e94e"></a>dof_I_component_i&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. the fully evaluated test shape function operator), extract its "component index" component that is associated with the <code>I</code>th local shape function. This is the equivalent of computing the inner product \( \left[ \bullet \right]^{I} \cdot \mathbf{e}_{i} \) where \( \left[ \bullet \right]^{I} \) denotes the qualified test shape function operator and \( \mathbf{e}_{i} \) is the \( i \)th Cartesian coordinate direction.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this filter will result in a slight performance penalty, as it will inhibit certain optimisations from being performed during the assembly process.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called if all shape functions in the finite element (system) are primitive. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4acc3c6969be48c9763f101891745480e6"></a>dof_I_component_j&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. the fully evaluated test shape function operator), extract its "component index" component that is associated with the <code>J</code>th local shape function. This is the equivalent of computing the inner product \( \left[ \bullet \right]^{I} \cdot \mathbf{e}_{j} \) where \( \left[ \bullet \right]^{I} \) denotes the qualified test shape function operator and \( \mathbf{e}_{j} \) is the \( j \)th Cartesian coordinate direction.</p>
<p>Notice that, for this filter, there is a cross-indexing of the shape function operator and the component that is to be extracted.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this filter will result in a slight performance penalty, as it will inhibit certain optimisations from being performed during the assembly process.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called if all shape functions in the finite element (system) are primitive. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a8d56c5d28292ad64b0978eda61d01e73"></a>dof_J_component_i&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. the fully evaluated trial shape function operator), extract its "component index" component that is associated with the <code>I</code>th local shape function. This is the equivalent of computing the inner product \( \left[ \bullet \right]^{J} \cdot \mathbf{e}_{i} \) where \( \left[ \bullet \right]^{J} \) denotes the qualified trial shape function operator and \( \mathbf{e}_{i} \) is the \( i \)th Cartesian coordinate direction.</p>
<p>Notice that, for this filter, there is a cross-indexing of the shape function operator and the component that is to be extracted.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this filter will result in a slight performance penalty, as it will inhibit certain optimisations from being performed during the assembly process.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called if all shape functions in the finite element (system) are primitive. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4ab22689254b0cc55000ab2509c90efcce"></a>dof_J_component_j&#160;</td><td class="fielddoc"><p>Of a vectorial or tensorial basis function result (i.e. the fully evaluated trial shape function operator), extract its "component index" component that is associated with the <code>J</code>th local shape function. This is the equivalent of computing the inner product \( \left[ \bullet \right]^{J} \cdot \mathbf{e}_{j} \) where \( \left[ \bullet \right]^{J} \) denotes the qualified trial shape function operator and \( \mathbf{e}_{j} \) is the \( j \)th Cartesian coordinate direction.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this filter will result in a slight performance penalty, as it will inhibit certain optimisations from being performed during the assembly process.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called if all shape functions in the finite element (system) are primitive. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="acaa0a4172ad5893b342da4aae68fb3a4a286506621645e37af87ab00331615d9b"></a>local_shape_function_kronecker_delta&#160;</td><td class="fielddoc"><p>Skip all contributions for which the shape function component is not equal for <code>component_i</code> and <code>component_j</code> of the <code>I</code>th and <code>J</code>th degrees of freedom. That is to say, that the associated Cartesian coordinate directions \( \mathbf{e}_{i} \) and \( \mathbf{e}_{j} \) are identical.</p>
<dl class="section note"><dt>Note</dt><dd>If used in isolation, then use of this filter still results in optimum performance code being executed by the assembler. </dd></dl>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00063">63</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a36e97adeeaa7ab0ed216e0587a70080c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e97adeeaa7ab0ed216e0587a70080c">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> WeakForms::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00186">186</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="a320830063be57b317a00c519cb979e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320830063be57b317a00c519cb979e04">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&amp; WeakForms::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00194">194</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="a7d14de582aceac693625e252b461da59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d14de582aceac693625e252b461da59">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> WeakForms::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00202">202</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
<a id="a0d1086e3a3e67706edcefd70e630050b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1086e3a3e67706edcefd70e630050b">&#9670;&nbsp;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&amp; WeakForms::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWeakForms.html#acaa0a4172ad5893b342da4aae68fb3a4">BilinearFormComponentFilter</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bilinear__forms_8h_source.html#l00210">210</a> of file <a class="el" href="bilinear__forms_8h_source.html">bilinear_forms.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
